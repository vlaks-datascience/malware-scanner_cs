using System;
using System.Collections.Generic;
using System.Linq;
using System.ServiceModel;
using System.Text;
using System.Threading.Tasks;
using DataModels;
using Contracts;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;
using SecurityManager;
using System.Threading;
using System.Security.Principal;
using System.IO;


namespace Client
{
    public class Program
    {
        static void Main(string[] args)
        {

            int N = 5000;//VREME POSLE KOJEG PONOVO PROVERAVA ZA PROCESE 20 sekundi
            //string address = "net.tcp://192.168.81.170:9999/IDS";
            string address = "net.tcp://localhost:9999/IDS";

            /// Define the expected certificate for signing ("<username>_sign" is the expected subject name).
            /// .NET WindowsIdentity class provides information about Windows user running the given process
            string signCertCN = FormatterForCert.ParseNameForCert(WindowsIdentity.GetCurrent().Name) + "_sign";

            /// Define the expected service certificate. It is required to establish cmmunication using certificates.
            string srvCertCN = "adminpera";

            NetTcpBinding binding = new NetTcpBinding();
            binding.Security.Transport.ClientCredentialType = TcpClientCredentialType.Certificate;


            /// Use CertManager class to obtain the certificate based on the "srvCertCN" representing the expected service identity.
            X509Certificate2 srvCert = CertManager.GetCertificateFromStorage(StoreName.TrustedPeople, StoreLocation.LocalMachine, srvCertCN);
            EndpointAddress addr = new EndpointAddress(new Uri(address),
                                      new X509CertificateEndpointIdentity(srvCert));

            WCFClient proxy = new WCFClient(binding, addr);

            /// Create a signature based on the "signCertCN"
            X509Certificate2 certificateSign = CertManager.GetCertificateFromStorage(StoreName.My,
                StoreLocation.LocalMachine, signCertCN);
            string address2 = "net.tcp://localhost:9998/IDS";
            //string address2 = "net.tcp://192.168.81.170:9998/IDS";
            NetTcpBinding binding2 = new NetTcpBinding();
            EndpointAddress addr2 = new EndpointAddress(new Uri(address2));
            WCFClient2 proxy2 = new WCFClient2(binding2, addr2);



            Thread t1 = new Thread(() => Menu(proxy2));
            t1.Start();

            while (true)
            {
                GetMProcesses(proxy2);
                try
                {
                    WCFClient.MalwareProcesses = FixDelete(proxy2);
                } catch (Exception e)
                {
                    Console.WriteLine(e);
                }
                Process[] processlist = Process.GetProcesses();
                foreach (Process theProcess in processlist)
                {
                    if (WCFClient.MalwareProcesses.ContainsKey(theProcess.ProcessName))
                    {
                        WCFClient.MalwareProcesses[theProcess.ProcessName] += 1;
                        string message = DateTime.Now + " -> " + "Name: " + theProcess.ProcessName + " | Criticality: " + CLevel(WCFClient.MalwareProcesses[theProcess.ProcessName]);
                        if (WCFClient.MalwareProcesses[theProcess.ProcessName] >= 3)
                        {
                            Audit.ProcessCritical(theProcess.ProcessName, DateTime.Now, WCFClient.MalwareProcesses[theProcess.ProcessName]);
                        }
                        byte[] signature = DigitalSignature.Create(message, HashAlgorithm.SHA1, certificateSign);
                        proxy.LogUnauthorizedProcess(message, signature);


                    }
                }
                Thread.Sleep(N);
            }
        }

        public static void Menu(WCFClient2 proxy)
        {
            string option = "";
            while (true)
            {
                Console.WriteLine("---------------------------------");
                Console.WriteLine("   Choose option: ");
                Console.WriteLine("1) Read configuration");
                Console.WriteLine("2) Add process");
                Console.WriteLine("3) Remove process");
                Console.WriteLine("4) Update process");
                Console.WriteLine("5) Delete config file");
                Console.Write("Your Option ---> ");
                option = Console.ReadLine();
                switch (option)
                {
                    case "1":
                        foreach (var x in proxy.ReadConfiguration())
                        {
                            Console.WriteLine(x);
                        }
                        break;
                    case "2":
                        Console.Write("Enter new process name: ");
                        string newProcess = Console.ReadLine();
                        Console.WriteLine();
                        Console.WriteLine(proxy.AddProcess(newProcess));
                        break;
                    case "3":
                        Console.Write("Enter process name: ");
                        string deleteProcess = Console.ReadLine();
                        Console.WriteLine(proxy.RemoveProcess(deleteProcess));
                        break;
                    case "4":
                        Console.Write("\nEnter old process name: ");
                        string Old = Console.ReadLine();
                        Console.Write("Enter new process name: ");
                        string New = Console.ReadLine();
                        Console.WriteLine(proxy.ModifyProcess(Old, New));
                        break;
                    case "5":
                        Console.WriteLine(proxy.DeleteConfigurationFile());
                        break;
                    default:
                        Console.WriteLine("You chose an option that doesn't exist! Try again.");
                        break;
                }
            }
        }

        static string CLevel(int n)
        {
            if (n == 1)
            {
                return CriticalityLevel.Information.ToString();
            }
            else if (n == 2)
            {
                return CriticalityLevel.Warning.ToString();
            }
            else
            {
                return CriticalityLevel.Critical.ToString();
            }
        }

        static void GetMProcesses(WCFClient2 proxy2)
        {
            List<string> ml = proxy2.GetMalwareProcesses();
            foreach (string p in ml)
            {
                if (!WCFClient.MalwareProcesses.ContainsKey(p))
                    WCFClient.MalwareProcesses.Add(p, 0);
            }
        }

        static Dictionary<string, int> FixDelete(WCFClient2 proxy2)
        {
            Dictionary<string, int> fix = WCFClient.MalwareProcesses;
            List<string> ml = proxy2.GetMalwareProcesses();
            foreach (string mp in fix.Keys.ToList())
            {
                if (!ml.Contains(mp))
                {
                    fix.Remove(mp);
                }
            }
            return fix;
        }
    }
}
